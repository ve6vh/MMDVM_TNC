/*
 *   Copyright (C) 2023 by Jonathan Naylor G4KLX
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include "Config.h"

#include "Globals.h"
#include "Hamming.h"

const uint8_t ENCODING_TABLE[] = {0x00U,	// 0x00
                                  0x71U,	// 0x01
                                  0x62U,	// 0x02
                                  0x13U,	// 0x03
                                  0x54U,	// 0x04
                                  0x25U,	// 0x05
                                  0x36U,	// 0x06
                                  0x47U,	// 0x07
                                  0x38U,	// 0x08
                                  0x49U,	// 0x09
                                  0x5AU,	// 0x0A
                                  0x2BU,	// 0x0B
                                  0x6CU,	// 0x0C
                                  0x1DU,	// 0x0D
                                  0x0EU,	// 0x0E
                                  0x7FU};	// 0x0F

const uint8_t DECODING_TABLE[] =
{
  0x00U, 0x00U, 0x00U, 0x03U, 0x00U, 0x05U, 0x0EU, 0x07U,     // 0x00 to 0x07
  0x00U, 0x09U, 0x0EU, 0x0BU, 0x0EU, 0x0DU, 0x0EU, 0x0EU,     // 0x08 to 0x0F
  0x00U, 0x03U, 0x03U, 0x03U, 0x04U, 0x0DU, 0x06U, 0x03U,     // 0x10 to 0x17
  0x08U, 0x0DU, 0x0AU, 0x03U, 0x0DU, 0x0DU, 0x0EU, 0x0DU,     // 0x18 to 0x1F
  0x00U, 0x05U, 0x02U, 0x0BU, 0x05U, 0x05U, 0x06U, 0x05U,     // 0x20 to 0x27
  0x08U, 0x0BU, 0x0BU, 0x0BU, 0x0CU, 0x05U, 0x0EU, 0x0BU,     // 0x28 to 0x2F
  0x08U, 0x01U, 0x06U, 0x03U, 0x06U, 0x05U, 0x06U, 0x06U,     // 0x30 to 0x37
  0x08U, 0x08U, 0x08U, 0x0BU, 0x08U, 0x0DU, 0x06U, 0x0FU,     // 0x38 to 0x3F
  0x00U, 0x09U, 0x02U, 0x07U, 0x04U, 0x07U, 0x07U, 0x07U,     // 0x40 to 0x47
  0x09U, 0x09U, 0x0AU, 0x09U, 0x0CU, 0x09U, 0x0EU, 0x07U,     // 0x48 to 0x4F
  0x04U, 0x01U, 0x0AU, 0x03U, 0x04U, 0x04U, 0x04U, 0x07U,     // 0x50 to 0x57
  0x0AU, 0x09U, 0x0AU, 0x0AU, 0x04U, 0x0DU, 0x0AU, 0x0FU,     // 0x58 to 0x5F
  0x02U, 0x01U, 0x02U, 0x02U, 0x0CU, 0x05U, 0x02U, 0x07U,     // 0x60 to 0x67
  0x0CU, 0x09U, 0x02U, 0x0BU, 0x0CU, 0x0CU, 0x0CU, 0x0FU,     // 0x68 to 0x6F
  0x01U, 0x01U, 0x02U, 0x01U, 0x04U, 0x01U, 0x06U, 0x0FU,     // 0x70 to 0x77
  0x08U, 0x01U, 0x0AU, 0x0FU, 0x0CU, 0x0FU, 0x0FU, 0x0FU      // 0x78 to 0x7F
};

CHamming::CHamming()
{
}

uint8_t CHamming::encode(uint8_t data) const
{
  return ENCODING_TABLE[data & 0x0FU];
}

uint8_t CHamming::decode(uint8_t data) const
{
  return DECODING_TABLE[data & 0x7FU];
}

